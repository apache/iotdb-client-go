// Code generated by Thrift Compiler (0.14.1). DO NOT EDIT.

package common

import(
	"bytes"
	"context"
	"database/sql/driver"
	"errors"
	"fmt"
	"time"
	"github.com/apache/thrift/lib/go/thrift"
)

// (needed to ensure safety because of naive import list construction.)
var _ = thrift.ZERO
var _ = fmt.Printf
var _ = context.Background
var _ = time.Now
var _ = bytes.Equal

type TConsensusGroupType int64
const (
  TConsensusGroupType_ConfigRegion TConsensusGroupType = 0
  TConsensusGroupType_DataRegion TConsensusGroupType = 1
  TConsensusGroupType_SchemaRegion TConsensusGroupType = 2
)

func (p TConsensusGroupType) String() string {
  switch p {
  case TConsensusGroupType_ConfigRegion: return "ConfigRegion"
  case TConsensusGroupType_DataRegion: return "DataRegion"
  case TConsensusGroupType_SchemaRegion: return "SchemaRegion"
  }
  return "<UNSET>"
}

func TConsensusGroupTypeFromString(s string) (TConsensusGroupType, error) {
  switch s {
  case "ConfigRegion": return TConsensusGroupType_ConfigRegion, nil 
  case "DataRegion": return TConsensusGroupType_DataRegion, nil 
  case "SchemaRegion": return TConsensusGroupType_SchemaRegion, nil 
  }
  return TConsensusGroupType(0), fmt.Errorf("not a valid TConsensusGroupType string")
}


func TConsensusGroupTypePtr(v TConsensusGroupType) *TConsensusGroupType { return &v }

func (p TConsensusGroupType) MarshalText() ([]byte, error) {
return []byte(p.String()), nil
}

func (p *TConsensusGroupType) UnmarshalText(text []byte) error {
q, err := TConsensusGroupTypeFromString(string(text))
if (err != nil) {
return err
}
*p = q
return nil
}

func (p *TConsensusGroupType) Scan(value interface{}) error {
v, ok := value.(int64)
if !ok {
return errors.New("Scan value is not int64")
}
*p = TConsensusGroupType(v)
return nil
}

func (p * TConsensusGroupType) Value() (driver.Value, error) {
  if p == nil {
    return nil, nil
  }
return int64(*p), nil
}
type TRegionMigrateFailedType int64
const (
  TRegionMigrateFailedType_AddPeerFailed TRegionMigrateFailedType = 0
  TRegionMigrateFailedType_RemovePeerFailed TRegionMigrateFailedType = 1
  TRegionMigrateFailedType_RemoveConsensusGroupFailed TRegionMigrateFailedType = 2
  TRegionMigrateFailedType_DeleteRegionFailed TRegionMigrateFailedType = 3
  TRegionMigrateFailedType_CreateRegionFailed TRegionMigrateFailedType = 4
)

func (p TRegionMigrateFailedType) String() string {
  switch p {
  case TRegionMigrateFailedType_AddPeerFailed: return "AddPeerFailed"
  case TRegionMigrateFailedType_RemovePeerFailed: return "RemovePeerFailed"
  case TRegionMigrateFailedType_RemoveConsensusGroupFailed: return "RemoveConsensusGroupFailed"
  case TRegionMigrateFailedType_DeleteRegionFailed: return "DeleteRegionFailed"
  case TRegionMigrateFailedType_CreateRegionFailed: return "CreateRegionFailed"
  }
  return "<UNSET>"
}

func TRegionMigrateFailedTypeFromString(s string) (TRegionMigrateFailedType, error) {
  switch s {
  case "AddPeerFailed": return TRegionMigrateFailedType_AddPeerFailed, nil 
  case "RemovePeerFailed": return TRegionMigrateFailedType_RemovePeerFailed, nil 
  case "RemoveConsensusGroupFailed": return TRegionMigrateFailedType_RemoveConsensusGroupFailed, nil 
  case "DeleteRegionFailed": return TRegionMigrateFailedType_DeleteRegionFailed, nil 
  case "CreateRegionFailed": return TRegionMigrateFailedType_CreateRegionFailed, nil 
  }
  return TRegionMigrateFailedType(0), fmt.Errorf("not a valid TRegionMigrateFailedType string")
}


func TRegionMigrateFailedTypePtr(v TRegionMigrateFailedType) *TRegionMigrateFailedType { return &v }

func (p TRegionMigrateFailedType) MarshalText() ([]byte, error) {
return []byte(p.String()), nil
}

func (p *TRegionMigrateFailedType) UnmarshalText(text []byte) error {
q, err := TRegionMigrateFailedTypeFromString(string(text))
if (err != nil) {
return err
}
*p = q
return nil
}

func (p *TRegionMigrateFailedType) Scan(value interface{}) error {
v, ok := value.(int64)
if !ok {
return errors.New("Scan value is not int64")
}
*p = TRegionMigrateFailedType(v)
return nil
}

func (p * TRegionMigrateFailedType) Value() (driver.Value, error) {
  if p == nil {
    return nil, nil
  }
return int64(*p), nil
}
type ThrottleType int64
const (
  ThrottleType_REQUEST_NUMBER ThrottleType = 0
  ThrottleType_REQUEST_SIZE ThrottleType = 1
  ThrottleType_WRITE_NUMBER ThrottleType = 2
  ThrottleType_WRITE_SIZE ThrottleType = 3
  ThrottleType_READ_NUMBER ThrottleType = 4
  ThrottleType_READ_SIZE ThrottleType = 5
)

func (p ThrottleType) String() string {
  switch p {
  case ThrottleType_REQUEST_NUMBER: return "REQUEST_NUMBER"
  case ThrottleType_REQUEST_SIZE: return "REQUEST_SIZE"
  case ThrottleType_WRITE_NUMBER: return "WRITE_NUMBER"
  case ThrottleType_WRITE_SIZE: return "WRITE_SIZE"
  case ThrottleType_READ_NUMBER: return "READ_NUMBER"
  case ThrottleType_READ_SIZE: return "READ_SIZE"
  }
  return "<UNSET>"
}

func ThrottleTypeFromString(s string) (ThrottleType, error) {
  switch s {
  case "REQUEST_NUMBER": return ThrottleType_REQUEST_NUMBER, nil 
  case "REQUEST_SIZE": return ThrottleType_REQUEST_SIZE, nil 
  case "WRITE_NUMBER": return ThrottleType_WRITE_NUMBER, nil 
  case "WRITE_SIZE": return ThrottleType_WRITE_SIZE, nil 
  case "READ_NUMBER": return ThrottleType_READ_NUMBER, nil 
  case "READ_SIZE": return ThrottleType_READ_SIZE, nil 
  }
  return ThrottleType(0), fmt.Errorf("not a valid ThrottleType string")
}


func ThrottleTypePtr(v ThrottleType) *ThrottleType { return &v }

func (p ThrottleType) MarshalText() ([]byte, error) {
return []byte(p.String()), nil
}

func (p *ThrottleType) UnmarshalText(text []byte) error {
q, err := ThrottleTypeFromString(string(text))
if (err != nil) {
return err
}
*p = q
return nil
}

func (p *ThrottleType) Scan(value interface{}) error {
v, ok := value.(int64)
if !ok {
return errors.New("Scan value is not int64")
}
*p = ThrottleType(v)
return nil
}

func (p * ThrottleType) Value() (driver.Value, error) {
  if p == nil {
    return nil, nil
  }
return int64(*p), nil
}
type TAggregationType int64
const (
  TAggregationType_COUNT TAggregationType = 0
  TAggregationType_AVG TAggregationType = 1
  TAggregationType_SUM TAggregationType = 2
  TAggregationType_FIRST_VALUE TAggregationType = 3
  TAggregationType_LAST_VALUE TAggregationType = 4
  TAggregationType_MAX_TIME TAggregationType = 5
  TAggregationType_MIN_TIME TAggregationType = 6
  TAggregationType_MAX_VALUE TAggregationType = 7
  TAggregationType_MIN_VALUE TAggregationType = 8
  TAggregationType_EXTREME TAggregationType = 9
  TAggregationType_COUNT_IF TAggregationType = 10
  TAggregationType_TIME_DURATION TAggregationType = 11
  TAggregationType_MODE TAggregationType = 12
)

func (p TAggregationType) String() string {
  switch p {
  case TAggregationType_COUNT: return "COUNT"
  case TAggregationType_AVG: return "AVG"
  case TAggregationType_SUM: return "SUM"
  case TAggregationType_FIRST_VALUE: return "FIRST_VALUE"
  case TAggregationType_LAST_VALUE: return "LAST_VALUE"
  case TAggregationType_MAX_TIME: return "MAX_TIME"
  case TAggregationType_MIN_TIME: return "MIN_TIME"
  case TAggregationType_MAX_VALUE: return "MAX_VALUE"
  case TAggregationType_MIN_VALUE: return "MIN_VALUE"
  case TAggregationType_EXTREME: return "EXTREME"
  case TAggregationType_COUNT_IF: return "COUNT_IF"
  case TAggregationType_TIME_DURATION: return "TIME_DURATION"
  case TAggregationType_MODE: return "MODE"
  }
  return "<UNSET>"
}

func TAggregationTypeFromString(s string) (TAggregationType, error) {
  switch s {
  case "COUNT": return TAggregationType_COUNT, nil 
  case "AVG": return TAggregationType_AVG, nil 
  case "SUM": return TAggregationType_SUM, nil 
  case "FIRST_VALUE": return TAggregationType_FIRST_VALUE, nil 
  case "LAST_VALUE": return TAggregationType_LAST_VALUE, nil 
  case "MAX_TIME": return TAggregationType_MAX_TIME, nil 
  case "MIN_TIME": return TAggregationType_MIN_TIME, nil 
  case "MAX_VALUE": return TAggregationType_MAX_VALUE, nil 
  case "MIN_VALUE": return TAggregationType_MIN_VALUE, nil 
  case "EXTREME": return TAggregationType_EXTREME, nil 
  case "COUNT_IF": return TAggregationType_COUNT_IF, nil 
  case "TIME_DURATION": return TAggregationType_TIME_DURATION, nil 
  case "MODE": return TAggregationType_MODE, nil 
  }
  return TAggregationType(0), fmt.Errorf("not a valid TAggregationType string")
}


func TAggregationTypePtr(v TAggregationType) *TAggregationType { return &v }

func (p TAggregationType) MarshalText() ([]byte, error) {
return []byte(p.String()), nil
}

func (p *TAggregationType) UnmarshalText(text []byte) error {
q, err := TAggregationTypeFromString(string(text))
if (err != nil) {
return err
}
*p = q
return nil
}

func (p *TAggregationType) Scan(value interface{}) error {
v, ok := value.(int64)
if !ok {
return errors.New("Scan value is not int64")
}
*p = TAggregationType(v)
return nil
}

func (p * TAggregationType) Value() (driver.Value, error) {
  if p == nil {
    return nil, nil
  }
return int64(*p), nil
}
type TrainingState int64
const (
  TrainingState_PENDING TrainingState = 0
  TrainingState_RUNNING TrainingState = 1
  TrainingState_FINISHED TrainingState = 2
  TrainingState_FAILED TrainingState = 3
  TrainingState_DROPPING TrainingState = 4
)

func (p TrainingState) String() string {
  switch p {
  case TrainingState_PENDING: return "PENDING"
  case TrainingState_RUNNING: return "RUNNING"
  case TrainingState_FINISHED: return "FINISHED"
  case TrainingState_FAILED: return "FAILED"
  case TrainingState_DROPPING: return "DROPPING"
  }
  return "<UNSET>"
}

func TrainingStateFromString(s string) (TrainingState, error) {
  switch s {
  case "PENDING": return TrainingState_PENDING, nil 
  case "RUNNING": return TrainingState_RUNNING, nil 
  case "FINISHED": return TrainingState_FINISHED, nil 
  case "FAILED": return TrainingState_FAILED, nil 
  case "DROPPING": return TrainingState_DROPPING, nil 
  }
  return TrainingState(0), fmt.Errorf("not a valid TrainingState string")
}


func TrainingStatePtr(v TrainingState) *TrainingState { return &v }

func (p TrainingState) MarshalText() ([]byte, error) {
return []byte(p.String()), nil
}

func (p *TrainingState) UnmarshalText(text []byte) error {
q, err := TrainingStateFromString(string(text))
if (err != nil) {
return err
}
*p = q
return nil
}

func (p *TrainingState) Scan(value interface{}) error {
v, ok := value.(int64)
if !ok {
return errors.New("Scan value is not int64")
}
*p = TrainingState(v)
return nil
}

func (p * TrainingState) Value() (driver.Value, error) {
  if p == nil {
    return nil, nil
  }
return int64(*p), nil
}
type ModelTask int64
const (
  ModelTask_FORECAST ModelTask = 0
)

func (p ModelTask) String() string {
  switch p {
  case ModelTask_FORECAST: return "FORECAST"
  }
  return "<UNSET>"
}

func ModelTaskFromString(s string) (ModelTask, error) {
  switch s {
  case "FORECAST": return ModelTask_FORECAST, nil 
  }
  return ModelTask(0), fmt.Errorf("not a valid ModelTask string")
}


func ModelTaskPtr(v ModelTask) *ModelTask { return &v }

func (p ModelTask) MarshalText() ([]byte, error) {
return []byte(p.String()), nil
}

func (p *ModelTask) UnmarshalText(text []byte) error {
q, err := ModelTaskFromString(string(text))
if (err != nil) {
return err
}
*p = q
return nil
}

func (p *ModelTask) Scan(value interface{}) error {
v, ok := value.(int64)
if !ok {
return errors.New("Scan value is not int64")
}
*p = ModelTask(v)
return nil
}

func (p * ModelTask) Value() (driver.Value, error) {
  if p == nil {
    return nil, nil
  }
return int64(*p), nil
}
// Attributes:
//  - IP
//  - Port
type TEndPoint struct {
  IP string `thrift:"ip,1,required" db:"ip" json:"ip"`
  Port int32 `thrift:"port,2,required" db:"port" json:"port"`
}

func NewTEndPoint() *TEndPoint {
  return &TEndPoint{}
}


func (p *TEndPoint) GetIP() string {
  return p.IP
}

func (p *TEndPoint) GetPort() int32 {
  return p.Port
}
func (p *TEndPoint) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetIP bool = false;
  var issetPort bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetIP = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
        issetPort = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetIP{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field IP is not set"));
  }
  if !issetPort{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Port is not set"));
  }
  return nil
}

func (p *TEndPoint)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.IP = v
}
  return nil
}

func (p *TEndPoint)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Port = v
}
  return nil
}

func (p *TEndPoint) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "TEndPoint"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *TEndPoint) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "ip", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ip: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.IP)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.ip (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ip: ", p), err) }
  return err
}

func (p *TEndPoint) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "port", thrift.I32, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:port: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Port)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.port (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:port: ", p), err) }
  return err
}

func (p *TEndPoint) Equals(other *TEndPoint) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.IP != other.IP { return false }
  if p.Port != other.Port { return false }
  return true
}

func (p *TEndPoint) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("TEndPoint(%+v)", *p)
}

// Attributes:
//  - Code
//  - Message
//  - SubStatus
//  - RedirectNode
type TSStatus struct {
  Code int32 `thrift:"code,1,required" db:"code" json:"code"`
  Message *string `thrift:"message,2" db:"message" json:"message,omitempty"`
  SubStatus []*TSStatus `thrift:"subStatus,3" db:"subStatus" json:"subStatus,omitempty"`
  RedirectNode *TEndPoint `thrift:"redirectNode,4" db:"redirectNode" json:"redirectNode,omitempty"`
}

func NewTSStatus() *TSStatus {
  return &TSStatus{}
}


func (p *TSStatus) GetCode() int32 {
  return p.Code
}
var TSStatus_Message_DEFAULT string
func (p *TSStatus) GetMessage() string {
  if !p.IsSetMessage() {
    return TSStatus_Message_DEFAULT
  }
return *p.Message
}
var TSStatus_SubStatus_DEFAULT []*TSStatus

func (p *TSStatus) GetSubStatus() []*TSStatus {
  return p.SubStatus
}
var TSStatus_RedirectNode_DEFAULT *TEndPoint
func (p *TSStatus) GetRedirectNode() *TEndPoint {
  if !p.IsSetRedirectNode() {
    return TSStatus_RedirectNode_DEFAULT
  }
return p.RedirectNode
}
func (p *TSStatus) IsSetMessage() bool {
  return p.Message != nil
}

func (p *TSStatus) IsSetSubStatus() bool {
  return p.SubStatus != nil
}

func (p *TSStatus) IsSetRedirectNode() bool {
  return p.RedirectNode != nil
}

func (p *TSStatus) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetCode bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetCode = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetCode{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Code is not set"));
  }
  return nil
}

func (p *TSStatus)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Code = v
}
  return nil
}

func (p *TSStatus)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Message = &v
}
  return nil
}

func (p *TSStatus)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*TSStatus, 0, size)
  p.SubStatus =  tSlice
  for i := 0; i < size; i ++ {
    _elem0 := &TSStatus{}
    if err := _elem0.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem0), err)
    }
    p.SubStatus = append(p.SubStatus, _elem0)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *TSStatus)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  p.RedirectNode = &TEndPoint{}
  if err := p.RedirectNode.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.RedirectNode), err)
  }
  return nil
}

func (p *TSStatus) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "TSStatus"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *TSStatus) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:code: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Code)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.code (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:code: ", p), err) }
  return err
}

func (p *TSStatus) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetMessage() {
    if err := oprot.WriteFieldBegin(ctx, "message", thrift.STRING, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:message: ", p), err) }
    if err := oprot.WriteString(ctx, string(*p.Message)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.message (2) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:message: ", p), err) }
  }
  return err
}

func (p *TSStatus) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSubStatus() {
    if err := oprot.WriteFieldBegin(ctx, "subStatus", thrift.LIST, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:subStatus: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.SubStatus)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.SubStatus {
      if err := v.Write(ctx, oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:subStatus: ", p), err) }
  }
  return err
}

func (p *TSStatus) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetRedirectNode() {
    if err := oprot.WriteFieldBegin(ctx, "redirectNode", thrift.STRUCT, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:redirectNode: ", p), err) }
    if err := p.RedirectNode.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.RedirectNode), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:redirectNode: ", p), err) }
  }
  return err
}

func (p *TSStatus) Equals(other *TSStatus) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Code != other.Code { return false }
  if p.Message != other.Message {
    if p.Message == nil || other.Message == nil {
      return false
    }
    if (*p.Message) != (*other.Message) { return false }
  }
  if len(p.SubStatus) != len(other.SubStatus) { return false }
  for i, _tgt := range p.SubStatus {
    _src1 := other.SubStatus[i]
    if !_tgt.Equals(_src1) { return false }
  }
  if !p.RedirectNode.Equals(other.RedirectNode) { return false }
  return true
}

func (p *TSStatus) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("TSStatus(%+v)", *p)
}

// Attributes:
//  - Type
//  - ID
type TConsensusGroupId struct {
  Type TConsensusGroupType `thrift:"type,1,required" db:"type" json:"type"`
  ID int32 `thrift:"id,2,required" db:"id" json:"id"`
}

func NewTConsensusGroupId() *TConsensusGroupId {
  return &TConsensusGroupId{}
}


func (p *TConsensusGroupId) GetType() TConsensusGroupType {
  return p.Type
}

func (p *TConsensusGroupId) GetID() int32 {
  return p.ID
}
func (p *TConsensusGroupId) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetType bool = false;
  var issetID bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetType = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
        issetID = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetType{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Type is not set"));
  }
  if !issetID{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ID is not set"));
  }
  return nil
}

func (p *TConsensusGroupId)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  temp := TConsensusGroupType(v)
  p.Type = temp
}
  return nil
}

func (p *TConsensusGroupId)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.ID = v
}
  return nil
}

func (p *TConsensusGroupId) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "TConsensusGroupId"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *TConsensusGroupId) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "type", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:type: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Type)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.type (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:type: ", p), err) }
  return err
}

func (p *TConsensusGroupId) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "id", thrift.I32, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:id: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.ID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.id (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:id: ", p), err) }
  return err
}

func (p *TConsensusGroupId) Equals(other *TConsensusGroupId) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Type != other.Type { return false }
  if p.ID != other.ID { return false }
  return true
}

func (p *TConsensusGroupId) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("TConsensusGroupId(%+v)", *p)
}

// Attributes:
//  - SlotId
type TSeriesPartitionSlot struct {
  SlotId int32 `thrift:"slotId,1,required" db:"slotId" json:"slotId"`
}

func NewTSeriesPartitionSlot() *TSeriesPartitionSlot {
  return &TSeriesPartitionSlot{}
}


func (p *TSeriesPartitionSlot) GetSlotId() int32 {
  return p.SlotId
}
func (p *TSeriesPartitionSlot) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetSlotId bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetSlotId = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetSlotId{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field SlotId is not set"));
  }
  return nil
}

func (p *TSeriesPartitionSlot)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.SlotId = v
}
  return nil
}

func (p *TSeriesPartitionSlot) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "TSeriesPartitionSlot"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *TSeriesPartitionSlot) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "slotId", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:slotId: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.SlotId)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.slotId (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:slotId: ", p), err) }
  return err
}

func (p *TSeriesPartitionSlot) Equals(other *TSeriesPartitionSlot) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.SlotId != other.SlotId { return false }
  return true
}

func (p *TSeriesPartitionSlot) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("TSeriesPartitionSlot(%+v)", *p)
}

// Attributes:
//  - StartTime
type TTimePartitionSlot struct {
  StartTime int64 `thrift:"startTime,1,required" db:"startTime" json:"startTime"`
}

func NewTTimePartitionSlot() *TTimePartitionSlot {
  return &TTimePartitionSlot{}
}


func (p *TTimePartitionSlot) GetStartTime() int64 {
  return p.StartTime
}
func (p *TTimePartitionSlot) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetStartTime bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetStartTime = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetStartTime{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field StartTime is not set"));
  }
  return nil
}

func (p *TTimePartitionSlot)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.StartTime = v
}
  return nil
}

func (p *TTimePartitionSlot) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "TTimePartitionSlot"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *TTimePartitionSlot) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "startTime", thrift.I64, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:startTime: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.StartTime)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.startTime (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:startTime: ", p), err) }
  return err
}

func (p *TTimePartitionSlot) Equals(other *TTimePartitionSlot) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.StartTime != other.StartTime { return false }
  return true
}

func (p *TTimePartitionSlot) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("TTimePartitionSlot(%+v)", *p)
}

// Attributes:
//  - RegionId
//  - DataNodeLocations
type TRegionReplicaSet struct {
  RegionId *TConsensusGroupId `thrift:"regionId,1,required" db:"regionId" json:"regionId"`
  DataNodeLocations []*TDataNodeLocation `thrift:"dataNodeLocations,2,required" db:"dataNodeLocations" json:"dataNodeLocations"`
}

func NewTRegionReplicaSet() *TRegionReplicaSet {
  return &TRegionReplicaSet{}
}

var TRegionReplicaSet_RegionId_DEFAULT *TConsensusGroupId
func (p *TRegionReplicaSet) GetRegionId() *TConsensusGroupId {
  if !p.IsSetRegionId() {
    return TRegionReplicaSet_RegionId_DEFAULT
  }
return p.RegionId
}

func (p *TRegionReplicaSet) GetDataNodeLocations() []*TDataNodeLocation {
  return p.DataNodeLocations
}
func (p *TRegionReplicaSet) IsSetRegionId() bool {
  return p.RegionId != nil
}

func (p *TRegionReplicaSet) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetRegionId bool = false;
  var issetDataNodeLocations bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetRegionId = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
        issetDataNodeLocations = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetRegionId{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field RegionId is not set"));
  }
  if !issetDataNodeLocations{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field DataNodeLocations is not set"));
  }
  return nil
}

func (p *TRegionReplicaSet)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.RegionId = &TConsensusGroupId{}
  if err := p.RegionId.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.RegionId), err)
  }
  return nil
}

func (p *TRegionReplicaSet)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*TDataNodeLocation, 0, size)
  p.DataNodeLocations =  tSlice
  for i := 0; i < size; i ++ {
    _elem2 := &TDataNodeLocation{}
    if err := _elem2.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem2), err)
    }
    p.DataNodeLocations = append(p.DataNodeLocations, _elem2)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *TRegionReplicaSet) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "TRegionReplicaSet"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *TRegionReplicaSet) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "regionId", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:regionId: ", p), err) }
  if err := p.RegionId.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.RegionId), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:regionId: ", p), err) }
  return err
}

func (p *TRegionReplicaSet) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "dataNodeLocations", thrift.LIST, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:dataNodeLocations: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.DataNodeLocations)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.DataNodeLocations {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:dataNodeLocations: ", p), err) }
  return err
}

func (p *TRegionReplicaSet) Equals(other *TRegionReplicaSet) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if !p.RegionId.Equals(other.RegionId) { return false }
  if len(p.DataNodeLocations) != len(other.DataNodeLocations) { return false }
  for i, _tgt := range p.DataNodeLocations {
    _src3 := other.DataNodeLocations[i]
    if !_tgt.Equals(_src3) { return false }
  }
  return true
}

func (p *TRegionReplicaSet) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("TRegionReplicaSet(%+v)", *p)
}

// Attributes:
//  - CpuCoreNum
//  - MaxMemory
type TNodeResource struct {
  CpuCoreNum int32 `thrift:"cpuCoreNum,1,required" db:"cpuCoreNum" json:"cpuCoreNum"`
  MaxMemory int64 `thrift:"maxMemory,2,required" db:"maxMemory" json:"maxMemory"`
}

func NewTNodeResource() *TNodeResource {
  return &TNodeResource{}
}


func (p *TNodeResource) GetCpuCoreNum() int32 {
  return p.CpuCoreNum
}

func (p *TNodeResource) GetMaxMemory() int64 {
  return p.MaxMemory
}
func (p *TNodeResource) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetCpuCoreNum bool = false;
  var issetMaxMemory bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetCpuCoreNum = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
        issetMaxMemory = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetCpuCoreNum{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field CpuCoreNum is not set"));
  }
  if !issetMaxMemory{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field MaxMemory is not set"));
  }
  return nil
}

func (p *TNodeResource)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.CpuCoreNum = v
}
  return nil
}

func (p *TNodeResource)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.MaxMemory = v
}
  return nil
}

func (p *TNodeResource) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "TNodeResource"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *TNodeResource) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "cpuCoreNum", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:cpuCoreNum: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.CpuCoreNum)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.cpuCoreNum (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:cpuCoreNum: ", p), err) }
  return err
}

func (p *TNodeResource) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "maxMemory", thrift.I64, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:maxMemory: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.MaxMemory)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.maxMemory (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:maxMemory: ", p), err) }
  return err
}

func (p *TNodeResource) Equals(other *TNodeResource) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.CpuCoreNum != other.CpuCoreNum { return false }
  if p.MaxMemory != other.MaxMemory { return false }
  return true
}

func (p *TNodeResource) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("TNodeResource(%+v)", *p)
}

// Attributes:
//  - ConfigNodeId
//  - InternalEndPoint
//  - ConsensusEndPoint
type TConfigNodeLocation struct {
  ConfigNodeId int32 `thrift:"configNodeId,1,required" db:"configNodeId" json:"configNodeId"`
  InternalEndPoint *TEndPoint `thrift:"internalEndPoint,2,required" db:"internalEndPoint" json:"internalEndPoint"`
  ConsensusEndPoint *TEndPoint `thrift:"consensusEndPoint,3,required" db:"consensusEndPoint" json:"consensusEndPoint"`
}

func NewTConfigNodeLocation() *TConfigNodeLocation {
  return &TConfigNodeLocation{}
}


func (p *TConfigNodeLocation) GetConfigNodeId() int32 {
  return p.ConfigNodeId
}
var TConfigNodeLocation_InternalEndPoint_DEFAULT *TEndPoint
func (p *TConfigNodeLocation) GetInternalEndPoint() *TEndPoint {
  if !p.IsSetInternalEndPoint() {
    return TConfigNodeLocation_InternalEndPoint_DEFAULT
  }
return p.InternalEndPoint
}
var TConfigNodeLocation_ConsensusEndPoint_DEFAULT *TEndPoint
func (p *TConfigNodeLocation) GetConsensusEndPoint() *TEndPoint {
  if !p.IsSetConsensusEndPoint() {
    return TConfigNodeLocation_ConsensusEndPoint_DEFAULT
  }
return p.ConsensusEndPoint
}
func (p *TConfigNodeLocation) IsSetInternalEndPoint() bool {
  return p.InternalEndPoint != nil
}

func (p *TConfigNodeLocation) IsSetConsensusEndPoint() bool {
  return p.ConsensusEndPoint != nil
}

func (p *TConfigNodeLocation) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetConfigNodeId bool = false;
  var issetInternalEndPoint bool = false;
  var issetConsensusEndPoint bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetConfigNodeId = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
        issetInternalEndPoint = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
        issetConsensusEndPoint = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetConfigNodeId{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ConfigNodeId is not set"));
  }
  if !issetInternalEndPoint{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field InternalEndPoint is not set"));
  }
  if !issetConsensusEndPoint{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ConsensusEndPoint is not set"));
  }
  return nil
}

func (p *TConfigNodeLocation)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.ConfigNodeId = v
}
  return nil
}

func (p *TConfigNodeLocation)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.InternalEndPoint = &TEndPoint{}
  if err := p.InternalEndPoint.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.InternalEndPoint), err)
  }
  return nil
}

func (p *TConfigNodeLocation)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.ConsensusEndPoint = &TEndPoint{}
  if err := p.ConsensusEndPoint.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.ConsensusEndPoint), err)
  }
  return nil
}

func (p *TConfigNodeLocation) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "TConfigNodeLocation"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *TConfigNodeLocation) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "configNodeId", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:configNodeId: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.ConfigNodeId)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.configNodeId (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:configNodeId: ", p), err) }
  return err
}

func (p *TConfigNodeLocation) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "internalEndPoint", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:internalEndPoint: ", p), err) }
  if err := p.InternalEndPoint.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.InternalEndPoint), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:internalEndPoint: ", p), err) }
  return err
}

func (p *TConfigNodeLocation) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "consensusEndPoint", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:consensusEndPoint: ", p), err) }
  if err := p.ConsensusEndPoint.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.ConsensusEndPoint), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:consensusEndPoint: ", p), err) }
  return err
}

func (p *TConfigNodeLocation) Equals(other *TConfigNodeLocation) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.ConfigNodeId != other.ConfigNodeId { return false }
  if !p.InternalEndPoint.Equals(other.InternalEndPoint) { return false }
  if !p.ConsensusEndPoint.Equals(other.ConsensusEndPoint) { return false }
  return true
}

func (p *TConfigNodeLocation) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("TConfigNodeLocation(%+v)", *p)
}

// Attributes:
//  - DataNodeId
//  - ClientRpcEndPoint
//  - InternalEndPoint
//  - MPPDataExchangeEndPoint
//  - DataRegionConsensusEndPoint
//  - SchemaRegionConsensusEndPoint
type TDataNodeLocation struct {
  DataNodeId int32 `thrift:"dataNodeId,1,required" db:"dataNodeId" json:"dataNodeId"`
  ClientRpcEndPoint *TEndPoint `thrift:"clientRpcEndPoint,2,required" db:"clientRpcEndPoint" json:"clientRpcEndPoint"`
  InternalEndPoint *TEndPoint `thrift:"internalEndPoint,3,required" db:"internalEndPoint" json:"internalEndPoint"`
  MPPDataExchangeEndPoint *TEndPoint `thrift:"mPPDataExchangeEndPoint,4,required" db:"mPPDataExchangeEndPoint" json:"mPPDataExchangeEndPoint"`
  DataRegionConsensusEndPoint *TEndPoint `thrift:"dataRegionConsensusEndPoint,5,required" db:"dataRegionConsensusEndPoint" json:"dataRegionConsensusEndPoint"`
  SchemaRegionConsensusEndPoint *TEndPoint `thrift:"schemaRegionConsensusEndPoint,6,required" db:"schemaRegionConsensusEndPoint" json:"schemaRegionConsensusEndPoint"`
}

func NewTDataNodeLocation() *TDataNodeLocation {
  return &TDataNodeLocation{}
}


func (p *TDataNodeLocation) GetDataNodeId() int32 {
  return p.DataNodeId
}
var TDataNodeLocation_ClientRpcEndPoint_DEFAULT *TEndPoint
func (p *TDataNodeLocation) GetClientRpcEndPoint() *TEndPoint {
  if !p.IsSetClientRpcEndPoint() {
    return TDataNodeLocation_ClientRpcEndPoint_DEFAULT
  }
return p.ClientRpcEndPoint
}
var TDataNodeLocation_InternalEndPoint_DEFAULT *TEndPoint
func (p *TDataNodeLocation) GetInternalEndPoint() *TEndPoint {
  if !p.IsSetInternalEndPoint() {
    return TDataNodeLocation_InternalEndPoint_DEFAULT
  }
return p.InternalEndPoint
}
var TDataNodeLocation_MPPDataExchangeEndPoint_DEFAULT *TEndPoint
func (p *TDataNodeLocation) GetMPPDataExchangeEndPoint() *TEndPoint {
  if !p.IsSetMPPDataExchangeEndPoint() {
    return TDataNodeLocation_MPPDataExchangeEndPoint_DEFAULT
  }
return p.MPPDataExchangeEndPoint
}
var TDataNodeLocation_DataRegionConsensusEndPoint_DEFAULT *TEndPoint
func (p *TDataNodeLocation) GetDataRegionConsensusEndPoint() *TEndPoint {
  if !p.IsSetDataRegionConsensusEndPoint() {
    return TDataNodeLocation_DataRegionConsensusEndPoint_DEFAULT
  }
return p.DataRegionConsensusEndPoint
}
var TDataNodeLocation_SchemaRegionConsensusEndPoint_DEFAULT *TEndPoint
func (p *TDataNodeLocation) GetSchemaRegionConsensusEndPoint() *TEndPoint {
  if !p.IsSetSchemaRegionConsensusEndPoint() {
    return TDataNodeLocation_SchemaRegionConsensusEndPoint_DEFAULT
  }
return p.SchemaRegionConsensusEndPoint
}
func (p *TDataNodeLocation) IsSetClientRpcEndPoint() bool {
  return p.ClientRpcEndPoint != nil
}

func (p *TDataNodeLocation) IsSetInternalEndPoint() bool {
  return p.InternalEndPoint != nil
}

func (p *TDataNodeLocation) IsSetMPPDataExchangeEndPoint() bool {
  return p.MPPDataExchangeEndPoint != nil
}

func (p *TDataNodeLocation) IsSetDataRegionConsensusEndPoint() bool {
  return p.DataRegionConsensusEndPoint != nil
}

func (p *TDataNodeLocation) IsSetSchemaRegionConsensusEndPoint() bool {
  return p.SchemaRegionConsensusEndPoint != nil
}

func (p *TDataNodeLocation) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetDataNodeId bool = false;
  var issetClientRpcEndPoint bool = false;
  var issetInternalEndPoint bool = false;
  var issetMPPDataExchangeEndPoint bool = false;
  var issetDataRegionConsensusEndPoint bool = false;
  var issetSchemaRegionConsensusEndPoint bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetDataNodeId = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
        issetClientRpcEndPoint = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
        issetInternalEndPoint = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
        issetMPPDataExchangeEndPoint = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
        issetDataRegionConsensusEndPoint = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 6:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField6(ctx, iprot); err != nil {
          return err
        }
        issetSchemaRegionConsensusEndPoint = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetDataNodeId{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field DataNodeId is not set"));
  }
  if !issetClientRpcEndPoint{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ClientRpcEndPoint is not set"));
  }
  if !issetInternalEndPoint{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field InternalEndPoint is not set"));
  }
  if !issetMPPDataExchangeEndPoint{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field MPPDataExchangeEndPoint is not set"));
  }
  if !issetDataRegionConsensusEndPoint{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field DataRegionConsensusEndPoint is not set"));
  }
  if !issetSchemaRegionConsensusEndPoint{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field SchemaRegionConsensusEndPoint is not set"));
  }
  return nil
}

func (p *TDataNodeLocation)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.DataNodeId = v
}
  return nil
}

func (p *TDataNodeLocation)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.ClientRpcEndPoint = &TEndPoint{}
  if err := p.ClientRpcEndPoint.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.ClientRpcEndPoint), err)
  }
  return nil
}

func (p *TDataNodeLocation)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.InternalEndPoint = &TEndPoint{}
  if err := p.InternalEndPoint.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.InternalEndPoint), err)
  }
  return nil
}

func (p *TDataNodeLocation)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  p.MPPDataExchangeEndPoint = &TEndPoint{}
  if err := p.MPPDataExchangeEndPoint.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.MPPDataExchangeEndPoint), err)
  }
  return nil
}

func (p *TDataNodeLocation)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  p.DataRegionConsensusEndPoint = &TEndPoint{}
  if err := p.DataRegionConsensusEndPoint.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.DataRegionConsensusEndPoint), err)
  }
  return nil
}

func (p *TDataNodeLocation)  ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
  p.SchemaRegionConsensusEndPoint = &TEndPoint{}
  if err := p.SchemaRegionConsensusEndPoint.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SchemaRegionConsensusEndPoint), err)
  }
  return nil
}

func (p *TDataNodeLocation) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "TDataNodeLocation"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
    if err := p.writeField6(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *TDataNodeLocation) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "dataNodeId", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:dataNodeId: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.DataNodeId)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.dataNodeId (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:dataNodeId: ", p), err) }
  return err
}

func (p *TDataNodeLocation) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "clientRpcEndPoint", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:clientRpcEndPoint: ", p), err) }
  if err := p.ClientRpcEndPoint.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.ClientRpcEndPoint), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:clientRpcEndPoint: ", p), err) }
  return err
}

func (p *TDataNodeLocation) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "internalEndPoint", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:internalEndPoint: ", p), err) }
  if err := p.InternalEndPoint.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.InternalEndPoint), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:internalEndPoint: ", p), err) }
  return err
}

func (p *TDataNodeLocation) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "mPPDataExchangeEndPoint", thrift.STRUCT, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:mPPDataExchangeEndPoint: ", p), err) }
  if err := p.MPPDataExchangeEndPoint.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.MPPDataExchangeEndPoint), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:mPPDataExchangeEndPoint: ", p), err) }
  return err
}

func (p *TDataNodeLocation) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "dataRegionConsensusEndPoint", thrift.STRUCT, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:dataRegionConsensusEndPoint: ", p), err) }
  if err := p.DataRegionConsensusEndPoint.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.DataRegionConsensusEndPoint), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:dataRegionConsensusEndPoint: ", p), err) }
  return err
}

func (p *TDataNodeLocation) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "schemaRegionConsensusEndPoint", thrift.STRUCT, 6); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:schemaRegionConsensusEndPoint: ", p), err) }
  if err := p.SchemaRegionConsensusEndPoint.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SchemaRegionConsensusEndPoint), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 6:schemaRegionConsensusEndPoint: ", p), err) }
  return err
}

func (p *TDataNodeLocation) Equals(other *TDataNodeLocation) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.DataNodeId != other.DataNodeId { return false }
  if !p.ClientRpcEndPoint.Equals(other.ClientRpcEndPoint) { return false }
  if !p.InternalEndPoint.Equals(other.InternalEndPoint) { return false }
  if !p.MPPDataExchangeEndPoint.Equals(other.MPPDataExchangeEndPoint) { return false }
  if !p.DataRegionConsensusEndPoint.Equals(other.DataRegionConsensusEndPoint) { return false }
  if !p.SchemaRegionConsensusEndPoint.Equals(other.SchemaRegionConsensusEndPoint) { return false }
  return true
}

func (p *TDataNodeLocation) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("TDataNodeLocation(%+v)", *p)
}

// Attributes:
//  - Location
//  - Resource
type TDataNodeConfiguration struct {
  Location *TDataNodeLocation `thrift:"location,1,required" db:"location" json:"location"`
  Resource *TNodeResource `thrift:"resource,2,required" db:"resource" json:"resource"`
}

func NewTDataNodeConfiguration() *TDataNodeConfiguration {
  return &TDataNodeConfiguration{}
}

var TDataNodeConfiguration_Location_DEFAULT *TDataNodeLocation
func (p *TDataNodeConfiguration) GetLocation() *TDataNodeLocation {
  if !p.IsSetLocation() {
    return TDataNodeConfiguration_Location_DEFAULT
  }
return p.Location
}
var TDataNodeConfiguration_Resource_DEFAULT *TNodeResource
func (p *TDataNodeConfiguration) GetResource() *TNodeResource {
  if !p.IsSetResource() {
    return TDataNodeConfiguration_Resource_DEFAULT
  }
return p.Resource
}
func (p *TDataNodeConfiguration) IsSetLocation() bool {
  return p.Location != nil
}

func (p *TDataNodeConfiguration) IsSetResource() bool {
  return p.Resource != nil
}

func (p *TDataNodeConfiguration) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetLocation bool = false;
  var issetResource bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetLocation = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
        issetResource = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetLocation{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Location is not set"));
  }
  if !issetResource{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Resource is not set"));
  }
  return nil
}

func (p *TDataNodeConfiguration)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Location = &TDataNodeLocation{}
  if err := p.Location.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Location), err)
  }
  return nil
}

func (p *TDataNodeConfiguration)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Resource = &TNodeResource{}
  if err := p.Resource.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Resource), err)
  }
  return nil
}

func (p *TDataNodeConfiguration) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "TDataNodeConfiguration"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *TDataNodeConfiguration) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "location", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:location: ", p), err) }
  if err := p.Location.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Location), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:location: ", p), err) }
  return err
}

func (p *TDataNodeConfiguration) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "resource", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:resource: ", p), err) }
  if err := p.Resource.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Resource), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:resource: ", p), err) }
  return err
}

func (p *TDataNodeConfiguration) Equals(other *TDataNodeConfiguration) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if !p.Location.Equals(other.Location) { return false }
  if !p.Resource.Equals(other.Resource) { return false }
  return true
}

func (p *TDataNodeConfiguration) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("TDataNodeConfiguration(%+v)", *p)
}

// Attributes:
//  - IsSeq
//  - StorageGroups
type TFlushReq struct {
  IsSeq *string `thrift:"isSeq,1" db:"isSeq" json:"isSeq,omitempty"`
  StorageGroups []string `thrift:"storageGroups,2" db:"storageGroups" json:"storageGroups,omitempty"`
}

func NewTFlushReq() *TFlushReq {
  return &TFlushReq{}
}

var TFlushReq_IsSeq_DEFAULT string
func (p *TFlushReq) GetIsSeq() string {
  if !p.IsSetIsSeq() {
    return TFlushReq_IsSeq_DEFAULT
  }
return *p.IsSeq
}
var TFlushReq_StorageGroups_DEFAULT []string

func (p *TFlushReq) GetStorageGroups() []string {
  return p.StorageGroups
}
func (p *TFlushReq) IsSetIsSeq() bool {
  return p.IsSeq != nil
}

func (p *TFlushReq) IsSetStorageGroups() bool {
  return p.StorageGroups != nil
}

func (p *TFlushReq) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *TFlushReq)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.IsSeq = &v
}
  return nil
}

func (p *TFlushReq)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]string, 0, size)
  p.StorageGroups =  tSlice
  for i := 0; i < size; i ++ {
var _elem4 string
    if v, err := iprot.ReadString(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _elem4 = v
}
    p.StorageGroups = append(p.StorageGroups, _elem4)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *TFlushReq) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "TFlushReq"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *TFlushReq) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetIsSeq() {
    if err := oprot.WriteFieldBegin(ctx, "isSeq", thrift.STRING, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:isSeq: ", p), err) }
    if err := oprot.WriteString(ctx, string(*p.IsSeq)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.isSeq (1) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:isSeq: ", p), err) }
  }
  return err
}

func (p *TFlushReq) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetStorageGroups() {
    if err := oprot.WriteFieldBegin(ctx, "storageGroups", thrift.LIST, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:storageGroups: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.StorageGroups)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.StorageGroups {
      if err := oprot.WriteString(ctx, string(v)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:storageGroups: ", p), err) }
  }
  return err
}

func (p *TFlushReq) Equals(other *TFlushReq) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.IsSeq != other.IsSeq {
    if p.IsSeq == nil || other.IsSeq == nil {
      return false
    }
    if (*p.IsSeq) != (*other.IsSeq) { return false }
  }
  if len(p.StorageGroups) != len(other.StorageGroups) { return false }
  for i, _tgt := range p.StorageGroups {
    _src5 := other.StorageGroups[i]
    if _tgt != _src5 { return false }
  }
  return true
}

func (p *TFlushReq) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("TFlushReq(%+v)", *p)
}

// Attributes:
//  - Paths
type TSettleReq struct {
  Paths []string `thrift:"paths,1,required" db:"paths" json:"paths"`
}

func NewTSettleReq() *TSettleReq {
  return &TSettleReq{}
}


func (p *TSettleReq) GetPaths() []string {
  return p.Paths
}
func (p *TSettleReq) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetPaths bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetPaths = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetPaths{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Paths is not set"));
  }
  return nil
}

func (p *TSettleReq)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]string, 0, size)
  p.Paths =  tSlice
  for i := 0; i < size; i ++ {
var _elem6 string
    if v, err := iprot.ReadString(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _elem6 = v
}
    p.Paths = append(p.Paths, _elem6)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *TSettleReq) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "TSettleReq"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *TSettleReq) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "paths", thrift.LIST, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:paths: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.Paths)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.Paths {
    if err := oprot.WriteString(ctx, string(v)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:paths: ", p), err) }
  return err
}

func (p *TSettleReq) Equals(other *TSettleReq) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if len(p.Paths) != len(other.Paths) { return false }
  for i, _tgt := range p.Paths {
    _src7 := other.Paths[i]
    if _tgt != _src7 { return false }
  }
  return true
}

func (p *TSettleReq) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("TSettleReq(%+v)", *p)
}

// Attributes:
//  - NodeName
//  - NodeType
type TSchemaNode struct {
  NodeName string `thrift:"nodeName,1,required" db:"nodeName" json:"nodeName"`
  NodeType int8 `thrift:"nodeType,2,required" db:"nodeType" json:"nodeType"`
}

func NewTSchemaNode() *TSchemaNode {
  return &TSchemaNode{}
}


func (p *TSchemaNode) GetNodeName() string {
  return p.NodeName
}

func (p *TSchemaNode) GetNodeType() int8 {
  return p.NodeType
}
func (p *TSchemaNode) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetNodeName bool = false;
  var issetNodeType bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetNodeName = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.BYTE {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
        issetNodeType = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetNodeName{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field NodeName is not set"));
  }
  if !issetNodeType{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field NodeType is not set"));
  }
  return nil
}

func (p *TSchemaNode)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.NodeName = v
}
  return nil
}

func (p *TSchemaNode)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadByte(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  temp := int8(v)
  p.NodeType = temp
}
  return nil
}

func (p *TSchemaNode) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "TSchemaNode"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *TSchemaNode) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "nodeName", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:nodeName: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.NodeName)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.nodeName (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:nodeName: ", p), err) }
  return err
}

func (p *TSchemaNode) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "nodeType", thrift.BYTE, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:nodeType: ", p), err) }
  if err := oprot.WriteByte(ctx, int8(p.NodeType)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.nodeType (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:nodeType: ", p), err) }
  return err
}

func (p *TSchemaNode) Equals(other *TSchemaNode) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.NodeName != other.NodeName { return false }
  if p.NodeType != other.NodeType { return false }
  return true
}

func (p *TSchemaNode) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("TSchemaNode(%+v)", *p)
}

// Attributes:
//  - StorageGroupPathPattern
//  - TTL
type TSetTTLReq struct {
  StorageGroupPathPattern []string `thrift:"storageGroupPathPattern,1,required" db:"storageGroupPathPattern" json:"storageGroupPathPattern"`
  TTL int64 `thrift:"TTL,2,required" db:"TTL" json:"TTL"`
}

func NewTSetTTLReq() *TSetTTLReq {
  return &TSetTTLReq{}
}


func (p *TSetTTLReq) GetStorageGroupPathPattern() []string {
  return p.StorageGroupPathPattern
}

func (p *TSetTTLReq) GetTTL() int64 {
  return p.TTL
}
func (p *TSetTTLReq) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetStorageGroupPathPattern bool = false;
  var issetTTL bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetStorageGroupPathPattern = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
        issetTTL = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetStorageGroupPathPattern{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field StorageGroupPathPattern is not set"));
  }
  if !issetTTL{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field TTL is not set"));
  }
  return nil
}

func (p *TSetTTLReq)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]string, 0, size)
  p.StorageGroupPathPattern =  tSlice
  for i := 0; i < size; i ++ {
var _elem8 string
    if v, err := iprot.ReadString(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _elem8 = v
}
    p.StorageGroupPathPattern = append(p.StorageGroupPathPattern, _elem8)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *TSetTTLReq)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.TTL = v
}
  return nil
}

func (p *TSetTTLReq) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "TSetTTLReq"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *TSetTTLReq) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "storageGroupPathPattern", thrift.LIST, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:storageGroupPathPattern: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.StorageGroupPathPattern)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.StorageGroupPathPattern {
    if err := oprot.WriteString(ctx, string(v)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:storageGroupPathPattern: ", p), err) }
  return err
}

func (p *TSetTTLReq) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "TTL", thrift.I64, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:TTL: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.TTL)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.TTL (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:TTL: ", p), err) }
  return err
}

func (p *TSetTTLReq) Equals(other *TSetTTLReq) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if len(p.StorageGroupPathPattern) != len(other.StorageGroupPathPattern) { return false }
  for i, _tgt := range p.StorageGroupPathPattern {
    _src9 := other.StorageGroupPathPattern[i]
    if _tgt != _src9 { return false }
  }
  if p.TTL != other.TTL { return false }
  return true
}

func (p *TSetTTLReq) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("TSetTTLReq(%+v)", *p)
}

// Attributes:
//  - FileName
//  - File
type TFile struct {
  FileName string `thrift:"fileName,1,required" db:"fileName" json:"fileName"`
  File []byte `thrift:"file,2,required" db:"file" json:"file"`
}

func NewTFile() *TFile {
  return &TFile{}
}


func (p *TFile) GetFileName() string {
  return p.FileName
}

func (p *TFile) GetFile() []byte {
  return p.File
}
func (p *TFile) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetFileName bool = false;
  var issetFile bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetFileName = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
        issetFile = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetFileName{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field FileName is not set"));
  }
  if !issetFile{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field File is not set"));
  }
  return nil
}

func (p *TFile)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.FileName = v
}
  return nil
}

func (p *TFile)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.File = v
}
  return nil
}

func (p *TFile) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "TFile"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *TFile) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "fileName", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:fileName: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.FileName)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.fileName (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:fileName: ", p), err) }
  return err
}

func (p *TFile) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "file", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:file: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.File); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.file (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:file: ", p), err) }
  return err
}

func (p *TFile) Equals(other *TFile) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.FileName != other.FileName { return false }
  if bytes.Compare(p.File, other.File) != 0 { return false }
  return true
}

func (p *TFile) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("TFile(%+v)", *p)
}

// Attributes:
//  - Status
//  - Files
type TFilesResp struct {
  Status *TSStatus `thrift:"status,1,required" db:"status" json:"status"`
  Files []*TFile `thrift:"files,2,required" db:"files" json:"files"`
}

func NewTFilesResp() *TFilesResp {
  return &TFilesResp{}
}

var TFilesResp_Status_DEFAULT *TSStatus
func (p *TFilesResp) GetStatus() *TSStatus {
  if !p.IsSetStatus() {
    return TFilesResp_Status_DEFAULT
  }
return p.Status
}

func (p *TFilesResp) GetFiles() []*TFile {
  return p.Files
}
func (p *TFilesResp) IsSetStatus() bool {
  return p.Status != nil
}

func (p *TFilesResp) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetStatus bool = false;
  var issetFiles bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetStatus = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
        issetFiles = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetStatus{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Status is not set"));
  }
  if !issetFiles{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Files is not set"));
  }
  return nil
}

func (p *TFilesResp)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Status = &TSStatus{}
  if err := p.Status.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Status), err)
  }
  return nil
}

func (p *TFilesResp)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*TFile, 0, size)
  p.Files =  tSlice
  for i := 0; i < size; i ++ {
    _elem10 := &TFile{}
    if err := _elem10.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem10), err)
    }
    p.Files = append(p.Files, _elem10)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *TFilesResp) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "TFilesResp"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *TFilesResp) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "status", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:status: ", p), err) }
  if err := p.Status.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Status), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:status: ", p), err) }
  return err
}

func (p *TFilesResp) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "files", thrift.LIST, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:files: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Files)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.Files {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:files: ", p), err) }
  return err
}

func (p *TFilesResp) Equals(other *TFilesResp) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if !p.Status.Equals(other.Status) { return false }
  if len(p.Files) != len(other.Files) { return false }
  for i, _tgt := range p.Files {
    _src11 := other.Files[i]
    if !_tgt.Equals(_src11) { return false }
  }
  return true
}

func (p *TFilesResp) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("TFilesResp(%+v)", *p)
}

// Attributes:
//  - DiskSize
//  - DeviceNum
//  - TimeserieNum
type TSpaceQuota struct {
  DiskSize *int64 `thrift:"diskSize,1" db:"diskSize" json:"diskSize,omitempty"`
  DeviceNum *int64 `thrift:"deviceNum,2" db:"deviceNum" json:"deviceNum,omitempty"`
  TimeserieNum *int64 `thrift:"timeserieNum,3" db:"timeserieNum" json:"timeserieNum,omitempty"`
}

func NewTSpaceQuota() *TSpaceQuota {
  return &TSpaceQuota{}
}

var TSpaceQuota_DiskSize_DEFAULT int64
func (p *TSpaceQuota) GetDiskSize() int64 {
  if !p.IsSetDiskSize() {
    return TSpaceQuota_DiskSize_DEFAULT
  }
return *p.DiskSize
}
var TSpaceQuota_DeviceNum_DEFAULT int64
func (p *TSpaceQuota) GetDeviceNum() int64 {
  if !p.IsSetDeviceNum() {
    return TSpaceQuota_DeviceNum_DEFAULT
  }
return *p.DeviceNum
}
var TSpaceQuota_TimeserieNum_DEFAULT int64
func (p *TSpaceQuota) GetTimeserieNum() int64 {
  if !p.IsSetTimeserieNum() {
    return TSpaceQuota_TimeserieNum_DEFAULT
  }
return *p.TimeserieNum
}
func (p *TSpaceQuota) IsSetDiskSize() bool {
  return p.DiskSize != nil
}

func (p *TSpaceQuota) IsSetDeviceNum() bool {
  return p.DeviceNum != nil
}

func (p *TSpaceQuota) IsSetTimeserieNum() bool {
  return p.TimeserieNum != nil
}

func (p *TSpaceQuota) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *TSpaceQuota)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.DiskSize = &v
}
  return nil
}

func (p *TSpaceQuota)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.DeviceNum = &v
}
  return nil
}

func (p *TSpaceQuota)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.TimeserieNum = &v
}
  return nil
}

func (p *TSpaceQuota) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "TSpaceQuota"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *TSpaceQuota) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetDiskSize() {
    if err := oprot.WriteFieldBegin(ctx, "diskSize", thrift.I64, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:diskSize: ", p), err) }
    if err := oprot.WriteI64(ctx, int64(*p.DiskSize)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.diskSize (1) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:diskSize: ", p), err) }
  }
  return err
}

func (p *TSpaceQuota) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetDeviceNum() {
    if err := oprot.WriteFieldBegin(ctx, "deviceNum", thrift.I64, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:deviceNum: ", p), err) }
    if err := oprot.WriteI64(ctx, int64(*p.DeviceNum)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.deviceNum (2) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:deviceNum: ", p), err) }
  }
  return err
}

func (p *TSpaceQuota) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetTimeserieNum() {
    if err := oprot.WriteFieldBegin(ctx, "timeserieNum", thrift.I64, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:timeserieNum: ", p), err) }
    if err := oprot.WriteI64(ctx, int64(*p.TimeserieNum)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.timeserieNum (3) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:timeserieNum: ", p), err) }
  }
  return err
}

func (p *TSpaceQuota) Equals(other *TSpaceQuota) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.DiskSize != other.DiskSize {
    if p.DiskSize == nil || other.DiskSize == nil {
      return false
    }
    if (*p.DiskSize) != (*other.DiskSize) { return false }
  }
  if p.DeviceNum != other.DeviceNum {
    if p.DeviceNum == nil || other.DeviceNum == nil {
      return false
    }
    if (*p.DeviceNum) != (*other.DeviceNum) { return false }
  }
  if p.TimeserieNum != other.TimeserieNum {
    if p.TimeserieNum == nil || other.TimeserieNum == nil {
      return false
    }
    if (*p.TimeserieNum) != (*other.TimeserieNum) { return false }
  }
  return true
}

func (p *TSpaceQuota) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("TSpaceQuota(%+v)", *p)
}

// Attributes:
//  - TimeUnit
//  - SoftLimit
type TTimedQuota struct {
  TimeUnit int64 `thrift:"timeUnit,1,required" db:"timeUnit" json:"timeUnit"`
  SoftLimit int64 `thrift:"softLimit,2,required" db:"softLimit" json:"softLimit"`
}

func NewTTimedQuota() *TTimedQuota {
  return &TTimedQuota{}
}


func (p *TTimedQuota) GetTimeUnit() int64 {
  return p.TimeUnit
}

func (p *TTimedQuota) GetSoftLimit() int64 {
  return p.SoftLimit
}
func (p *TTimedQuota) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetTimeUnit bool = false;
  var issetSoftLimit bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetTimeUnit = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
        issetSoftLimit = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetTimeUnit{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field TimeUnit is not set"));
  }
  if !issetSoftLimit{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field SoftLimit is not set"));
  }
  return nil
}

func (p *TTimedQuota)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.TimeUnit = v
}
  return nil
}

func (p *TTimedQuota)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.SoftLimit = v
}
  return nil
}

func (p *TTimedQuota) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "TTimedQuota"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *TTimedQuota) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "timeUnit", thrift.I64, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:timeUnit: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.TimeUnit)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.timeUnit (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:timeUnit: ", p), err) }
  return err
}

func (p *TTimedQuota) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "softLimit", thrift.I64, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:softLimit: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.SoftLimit)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.softLimit (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:softLimit: ", p), err) }
  return err
}

func (p *TTimedQuota) Equals(other *TTimedQuota) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.TimeUnit != other.TimeUnit { return false }
  if p.SoftLimit != other.SoftLimit { return false }
  return true
}

func (p *TTimedQuota) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("TTimedQuota(%+v)", *p)
}

// Attributes:
//  - ThrottleLimit
//  - MemLimit
//  - CpuLimit
type TThrottleQuota struct {
  ThrottleLimit map[ThrottleType]*TTimedQuota `thrift:"throttleLimit,1" db:"throttleLimit" json:"throttleLimit,omitempty"`
  MemLimit *int64 `thrift:"memLimit,2" db:"memLimit" json:"memLimit,omitempty"`
  CpuLimit *int32 `thrift:"cpuLimit,3" db:"cpuLimit" json:"cpuLimit,omitempty"`
}

func NewTThrottleQuota() *TThrottleQuota {
  return &TThrottleQuota{}
}

var TThrottleQuota_ThrottleLimit_DEFAULT map[ThrottleType]*TTimedQuota

func (p *TThrottleQuota) GetThrottleLimit() map[ThrottleType]*TTimedQuota {
  return p.ThrottleLimit
}
var TThrottleQuota_MemLimit_DEFAULT int64
func (p *TThrottleQuota) GetMemLimit() int64 {
  if !p.IsSetMemLimit() {
    return TThrottleQuota_MemLimit_DEFAULT
  }
return *p.MemLimit
}
var TThrottleQuota_CpuLimit_DEFAULT int32
func (p *TThrottleQuota) GetCpuLimit() int32 {
  if !p.IsSetCpuLimit() {
    return TThrottleQuota_CpuLimit_DEFAULT
  }
return *p.CpuLimit
}
func (p *TThrottleQuota) IsSetThrottleLimit() bool {
  return p.ThrottleLimit != nil
}

func (p *TThrottleQuota) IsSetMemLimit() bool {
  return p.MemLimit != nil
}

func (p *TThrottleQuota) IsSetCpuLimit() bool {
  return p.CpuLimit != nil
}

func (p *TThrottleQuota) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.MAP {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *TThrottleQuota)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  _, _, size, err := iprot.ReadMapBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading map begin: ", err)
  }
  tMap := make(map[ThrottleType]*TTimedQuota, size)
  p.ThrottleLimit =  tMap
  for i := 0; i < size; i ++ {
var _key12 ThrottleType
    if v, err := iprot.ReadI32(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    temp := ThrottleType(v)
    _key12 = temp
}
    _val13 := &TTimedQuota{}
    if err := _val13.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _val13), err)
    }
    p.ThrottleLimit[_key12] = _val13
  }
  if err := iprot.ReadMapEnd(ctx); err != nil {
    return thrift.PrependError("error reading map end: ", err)
  }
  return nil
}

func (p *TThrottleQuota)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.MemLimit = &v
}
  return nil
}

func (p *TThrottleQuota)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.CpuLimit = &v
}
  return nil
}

func (p *TThrottleQuota) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "TThrottleQuota"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *TThrottleQuota) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetThrottleLimit() {
    if err := oprot.WriteFieldBegin(ctx, "throttleLimit", thrift.MAP, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:throttleLimit: ", p), err) }
    if err := oprot.WriteMapBegin(ctx, thrift.I32, thrift.STRUCT, len(p.ThrottleLimit)); err != nil {
      return thrift.PrependError("error writing map begin: ", err)
    }
    for k, v := range p.ThrottleLimit {
      if err := oprot.WriteI32(ctx, int32(k)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
      if err := v.Write(ctx, oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteMapEnd(ctx); err != nil {
      return thrift.PrependError("error writing map end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:throttleLimit: ", p), err) }
  }
  return err
}

func (p *TThrottleQuota) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetMemLimit() {
    if err := oprot.WriteFieldBegin(ctx, "memLimit", thrift.I64, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:memLimit: ", p), err) }
    if err := oprot.WriteI64(ctx, int64(*p.MemLimit)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.memLimit (2) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:memLimit: ", p), err) }
  }
  return err
}

func (p *TThrottleQuota) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetCpuLimit() {
    if err := oprot.WriteFieldBegin(ctx, "cpuLimit", thrift.I32, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:cpuLimit: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.CpuLimit)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.cpuLimit (3) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:cpuLimit: ", p), err) }
  }
  return err
}

func (p *TThrottleQuota) Equals(other *TThrottleQuota) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if len(p.ThrottleLimit) != len(other.ThrottleLimit) { return false }
  for k, _tgt := range p.ThrottleLimit {
    _src14 := other.ThrottleLimit[k]
    if !_tgt.Equals(_src14) { return false }
  }
  if p.MemLimit != other.MemLimit {
    if p.MemLimit == nil || other.MemLimit == nil {
      return false
    }
    if (*p.MemLimit) != (*other.MemLimit) { return false }
  }
  if p.CpuLimit != other.CpuLimit {
    if p.CpuLimit == nil || other.CpuLimit == nil {
      return false
    }
    if (*p.CpuLimit) != (*other.CpuLimit) { return false }
  }
  return true
}

func (p *TThrottleQuota) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("TThrottleQuota(%+v)", *p)
}

// Attributes:
//  - Database
//  - SpaceLimit
type TSetSpaceQuotaReq struct {
  Database []string `thrift:"database,1,required" db:"database" json:"database"`
  SpaceLimit *TSpaceQuota `thrift:"spaceLimit,2,required" db:"spaceLimit" json:"spaceLimit"`
}

func NewTSetSpaceQuotaReq() *TSetSpaceQuotaReq {
  return &TSetSpaceQuotaReq{}
}


func (p *TSetSpaceQuotaReq) GetDatabase() []string {
  return p.Database
}
var TSetSpaceQuotaReq_SpaceLimit_DEFAULT *TSpaceQuota
func (p *TSetSpaceQuotaReq) GetSpaceLimit() *TSpaceQuota {
  if !p.IsSetSpaceLimit() {
    return TSetSpaceQuotaReq_SpaceLimit_DEFAULT
  }
return p.SpaceLimit
}
func (p *TSetSpaceQuotaReq) IsSetSpaceLimit() bool {
  return p.SpaceLimit != nil
}

func (p *TSetSpaceQuotaReq) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetDatabase bool = false;
  var issetSpaceLimit bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetDatabase = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
        issetSpaceLimit = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetDatabase{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Database is not set"));
  }
  if !issetSpaceLimit{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field SpaceLimit is not set"));
  }
  return nil
}

func (p *TSetSpaceQuotaReq)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]string, 0, size)
  p.Database =  tSlice
  for i := 0; i < size; i ++ {
var _elem15 string
    if v, err := iprot.ReadString(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _elem15 = v
}
    p.Database = append(p.Database, _elem15)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *TSetSpaceQuotaReq)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.SpaceLimit = &TSpaceQuota{}
  if err := p.SpaceLimit.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SpaceLimit), err)
  }
  return nil
}

func (p *TSetSpaceQuotaReq) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "TSetSpaceQuotaReq"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *TSetSpaceQuotaReq) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "database", thrift.LIST, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:database: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.Database)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.Database {
    if err := oprot.WriteString(ctx, string(v)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:database: ", p), err) }
  return err
}

func (p *TSetSpaceQuotaReq) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "spaceLimit", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:spaceLimit: ", p), err) }
  if err := p.SpaceLimit.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SpaceLimit), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:spaceLimit: ", p), err) }
  return err
}

func (p *TSetSpaceQuotaReq) Equals(other *TSetSpaceQuotaReq) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if len(p.Database) != len(other.Database) { return false }
  for i, _tgt := range p.Database {
    _src16 := other.Database[i]
    if _tgt != _src16 { return false }
  }
  if !p.SpaceLimit.Equals(other.SpaceLimit) { return false }
  return true
}

func (p *TSetSpaceQuotaReq) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("TSetSpaceQuotaReq(%+v)", *p)
}

// Attributes:
//  - UserName
//  - ThrottleQuota
type TSetThrottleQuotaReq struct {
  UserName string `thrift:"userName,1,required" db:"userName" json:"userName"`
  ThrottleQuota *TThrottleQuota `thrift:"throttleQuota,2,required" db:"throttleQuota" json:"throttleQuota"`
}

func NewTSetThrottleQuotaReq() *TSetThrottleQuotaReq {
  return &TSetThrottleQuotaReq{}
}


func (p *TSetThrottleQuotaReq) GetUserName() string {
  return p.UserName
}
var TSetThrottleQuotaReq_ThrottleQuota_DEFAULT *TThrottleQuota
func (p *TSetThrottleQuotaReq) GetThrottleQuota() *TThrottleQuota {
  if !p.IsSetThrottleQuota() {
    return TSetThrottleQuotaReq_ThrottleQuota_DEFAULT
  }
return p.ThrottleQuota
}
func (p *TSetThrottleQuotaReq) IsSetThrottleQuota() bool {
  return p.ThrottleQuota != nil
}

func (p *TSetThrottleQuotaReq) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetUserName bool = false;
  var issetThrottleQuota bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetUserName = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
        issetThrottleQuota = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetUserName{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field UserName is not set"));
  }
  if !issetThrottleQuota{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ThrottleQuota is not set"));
  }
  return nil
}

func (p *TSetThrottleQuotaReq)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.UserName = v
}
  return nil
}

func (p *TSetThrottleQuotaReq)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.ThrottleQuota = &TThrottleQuota{}
  if err := p.ThrottleQuota.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.ThrottleQuota), err)
  }
  return nil
}

func (p *TSetThrottleQuotaReq) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "TSetThrottleQuotaReq"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *TSetThrottleQuotaReq) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "userName", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userName: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.UserName)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.userName (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userName: ", p), err) }
  return err
}

func (p *TSetThrottleQuotaReq) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "throttleQuota", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:throttleQuota: ", p), err) }
  if err := p.ThrottleQuota.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.ThrottleQuota), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:throttleQuota: ", p), err) }
  return err
}

func (p *TSetThrottleQuotaReq) Equals(other *TSetThrottleQuotaReq) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.UserName != other.UserName { return false }
  if !p.ThrottleQuota.Equals(other.ThrottleQuota) { return false }
  return true
}

func (p *TSetThrottleQuotaReq) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("TSetThrottleQuotaReq(%+v)", *p)
}

